[{"filePath":"C:\\Users\\arda\\.gemini\\antigravity\\scratch\\restin-ai\\frontend\\craco.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arda\\.gemini\\antigravity\\scratch\\restin-ai\\frontend\\eslint.config.mjs","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arda\\.gemini\\antigravity\\scratch\\restin-ai\\frontend\\migrate-colors.js","messages":[{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\#.","line":10,"column":37,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":10,"endColumn":38,"suggestions":[{"messageId":"removeEscape","fix":{"range":[306,307],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[306,306],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\#.","line":10,"column":57,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":10,"endColumn":58,"suggestions":[{"messageId":"removeEscape","fix":{"range":[326,327],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[326,326],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\#.","line":10,"column":77,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":10,"endColumn":78,"suggestions":[{"messageId":"removeEscape","fix":{"range":[346,347],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[346,346],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\#.","line":13,"column":37,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":13,"endColumn":38,"suggestions":[{"messageId":"removeEscape","fix":{"range":[450,451],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[450,450],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\#.","line":13,"column":57,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":13,"endColumn":58,"suggestions":[{"messageId":"removeEscape","fix":{"range":[470,471],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[470,470],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\#.","line":13,"column":77,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":13,"endColumn":78,"suggestions":[{"messageId":"removeEscape","fix":{"range":[490,491],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[490,490],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'match' is assigned a value but never used.","line":55,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":55,"endColumn":22}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const fs = require('fs');\r\nconst path = require('path');\r\n\r\nconst DIR_TO_SCAN = path.join(__dirname, 'src');\r\n\r\n// Regex patterns for the mass migration\r\n// We use word boundaries \\b to avoid partially replacing classes\r\nconst REPLACEMENTS = [\r\n    // Backgrounds Base\r\n    { from: /\\bbg-zinc-950\\b|\\bbg-\\[\\#0A0A0B\\]\\b|\\bbg-\\[\\#0F0F10\\]\\b|\\bbg-\\[\\#09090b\\]\\b/g, to: 'bg-background' },\r\n\r\n    // Backgrounds Cards\r\n    { from: /\\bbg-zinc-900\\b|\\bbg-\\[\\#18181b\\]\\b|\\bbg-\\[\\#1a1a1a\\]\\b|\\bbg-\\[\\#161617\\]\\b/g, to: 'bg-card' },\r\n\r\n    // Backgrounds Secondary/Muted\r\n    { from: /\\bbg-zinc-800\\b/g, to: 'bg-secondary' },\r\n\r\n    // Text\r\n    { from: /\\btext-white\\b|\\btext-zinc-50\\b|\\btext-zinc-100\\b/g, to: 'text-foreground' },\r\n    { from: /\\btext-zinc-200\\b|\\btext-zinc-300\\b/g, to: 'text-secondary-foreground' },\r\n    { from: /\\btext-zinc-400\\b|\\btext-zinc-500\\b|\\btext-zinc-600\\b/g, to: 'text-muted-foreground' },\r\n\r\n    // Borders\r\n    { from: /\\bborder-zinc-800\\b|\\bborder-zinc-700\\b|\\bborder-white\\/5\\b|\\bborder-white\\/10\\b/g, to: 'border-border' },\r\n    { from: /\\bdivide-zinc-800\\b|\\bdivide-zinc-700\\b/g, to: 'divide-border' },\r\n\r\n    // Hovers\r\n    { from: /\\bhover:bg-zinc-800\\b|\\bhover:bg-zinc-700\\b/g, to: 'hover:bg-secondary/80' },\r\n    { from: /\\bhover:text-white\\b|\\bhover:text-zinc-100\\b/g, to: 'hover:text-foreground' }\r\n];\r\n\r\nlet filesChanged = 0;\r\nlet totalReplacementsMade = 0;\r\n\r\nfunction walkDir(dir) {\r\n    const files = fs.readdirSync(dir);\r\n    for (const file of files) {\r\n        const fullPath = path.join(dir, file);\r\n        if (fs.statSync(fullPath).isDirectory()) {\r\n            walkDir(fullPath);\r\n        } else if (fullPath.endsWith('.jsx') || fullPath.endsWith('.tsx') || fullPath.endsWith('.js') || fullPath.endsWith('.ts')) {\r\n            processFile(fullPath);\r\n        }\r\n    }\r\n}\r\n\r\nfunction processFile(filePath) {\r\n    let content = fs.readFileSync(filePath, 'utf-8');\r\n    let originalContent = content;\r\n    let fileReplacements = 0;\r\n\r\n    REPLACEMENTS.forEach(rule => {\r\n        let match;\r\n        // Count replacements for logging\r\n        while ((match = rule.from.exec(originalContent)) !== null) {\r\n            fileReplacements++;\r\n            totalReplacementsMade++;\r\n        }\r\n        // Do actual replace\r\n        content = content.replace(rule.from, rule.to);\r\n    });\r\n\r\n    if (content !== originalContent) {\r\n        fs.writeFileSync(filePath, content, 'utf-8');\r\n        filesChanged++;\r\n        console.log(`Updated: ${path.relative(__dirname, filePath)} (${fileReplacements} replacements)`);\r\n    }\r\n}\r\n\r\nconsole.log('­şöä Starting Color Migration Script...');\r\nconsole.log('Scanning directory:', DIR_TO_SCAN);\r\n\r\ntry {\r\n    walkDir(DIR_TO_SCAN);\r\n    console.log('\\nÔ£à Migration Complete!');\r\n    console.log(`ÔÇó Files Modified: ${filesChanged}`);\r\n    console.log(`ÔÇó Total Class Replacements: ${totalReplacementsMade}`);\r\n} catch (error) {\r\n    console.error('ÔØî Error during migration:', error);\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arda\\.gemini\\antigravity\\scratch\\restin-ai\\frontend\\migrate-spacing-zindex.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arda\\.gemini\\antigravity\\scratch\\restin-ai\\frontend\\plugins\\health-check\\health-endpoints.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arda\\.gemini\\antigravity\\scratch\\restin-ai\\frontend\\plugins\\health-check\\webpack-health-plugin.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arda\\.gemini\\antigravity\\scratch\\restin-ai\\frontend\\plugins\\visual-edits\\babel-metadata-plugin.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":69,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":69,"endColumn":17},{"ruleId":"no-extra-boolean-cast","severity":2,"message":"Redundant double negation.","line":736,"column":16,"nodeType":"UnaryExpression","messageId":"unexpectedNegation","endLine":736,"endColumn":25,"fix":{"range":[21208,21217],"text":"absPath"}},{"ruleId":"no-extra-boolean-cast","severity":2,"message":"Redundant double negation.","line":749,"column":16,"nodeType":"UnaryExpression","messageId":"unexpectedNegation","endLine":749,"endColumn":25,"fix":{"range":[21693,21702],"text":"absPath"}}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":2,"fixableWarningCount":0,"source":"// babel-metadata-plugin.js\r\n// Babel plugin for JSX transformation - adds metadata to all elements\r\nconst path = require(\"path\");\r\nconst fs = require(\"fs\");\r\n\r\n// ÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇ\r\n// ===== Dynamic composite detection (auto-exclude) =====\r\nconst EXTENSIONS = [\".tsx\", \".ts\", \".jsx\", \".js\"];\r\nconst PROJECT_ROOT = path.resolve(__dirname, '../..'); // frontend root (../../ from plugins/visual-edits/)\r\nconst SRC_ALIAS = path.resolve(PROJECT_ROOT, \"src\");\r\n\r\nconst RESOLVE_CACHE = new Map(); // key: fromFile::source -> absPath | null\r\nconst FILE_AST_CACHE = new Map(); // absPath -> { ast, mtimeMs }\r\nconst PORTAL_COMP_CACHE = new Map(); // key: absPath::exportName -> boolean\r\nconst DYNAMIC_COMP_CACHE = new Map(); // key: absPath::exportName -> boolean\r\nconst BINDING_DYNAMIC_CACHE = new WeakMap(); // node -> boolean\r\n\r\nfunction resolveImportPath(source, fromFile) {\r\n  const cacheKey = `${fromFile}::${source}`;\r\n  if (RESOLVE_CACHE.has(cacheKey)) return RESOLVE_CACHE.get(cacheKey);\r\n\r\n  let base;\r\n  if (source.startsWith(\"@/\")) {\r\n    base = path.join(SRC_ALIAS, source.slice(2));\r\n  } else if (source.startsWith(\"./\") || source.startsWith(\"../\")) {\r\n    base = path.resolve(path.dirname(fromFile), source);\r\n  } else {\r\n    // bare specifier (node_modules) ÔÇö skip analysis\r\n    RESOLVE_CACHE.set(cacheKey, null);\r\n    return null;\r\n  }\r\n\r\n  // try direct file\r\n  for (const ext of EXTENSIONS) {\r\n    const file = base.endsWith(ext) ? base : base + ext;\r\n    if (fs.existsSync(file) && fs.statSync(file).isFile()) {\r\n      RESOLVE_CACHE.set(cacheKey, file);\r\n      return file;\r\n    }\r\n  }\r\n  // try index.* in directory\r\n  if (fs.existsSync(base) && fs.statSync(base).isDirectory()) {\r\n    for (const ext of EXTENSIONS) {\r\n      const idx = path.join(base, \"index\" + ext);\r\n      if (fs.existsSync(idx)) {\r\n        RESOLVE_CACHE.set(cacheKey, idx);\r\n        return idx;\r\n      }\r\n    }\r\n  }\r\n\r\n  RESOLVE_CACHE.set(cacheKey, null);\r\n  return null;\r\n}\r\n\r\nfunction parseFileAst(absPath, parser) {\r\n  try {\r\n    const stat = fs.statSync(absPath);\r\n    const cached = FILE_AST_CACHE.get(absPath);\r\n    if (cached && cached.mtimeMs === stat.mtimeMs) return cached.ast;\r\n\r\n    const code = fs.readFileSync(absPath, \"utf8\");\r\n    const ast = parser.parse(code, {\r\n      sourceType: \"module\",\r\n      plugins: [\"jsx\", \"typescript\"],\r\n    });\r\n    FILE_AST_CACHE.set(absPath, { ast, mtimeMs: stat.mtimeMs });\r\n    return ast;\r\n  } catch (error) {\r\n    return null;\r\n  }\r\n}\r\n\r\nfunction jsxNameOf(openingEl, t) {\r\n  const n = openingEl?.name;\r\n  if (t.isJSXIdentifier(n)) return n.name;\r\n  if (t.isJSXMemberExpression(n)) return n.property.name; // <X.Y>\r\n  return null;\r\n}\r\n\r\nconst PORTAL_SUFFIX_RE =\r\n  /(Trigger|Portal|Content|Overlay|Viewport|Anchor|Arrow)$/;\r\n\r\nfunction isPortalishName(name, RADIX_ROOTS) {\r\n  if (!name) return false;\r\n  return RADIX_ROOTS.has(name) || PORTAL_SUFFIX_RE.test(name);\r\n}\r\n\r\n// Analyze a specific exported component in a file\r\nfunction fileExportHasPortals({\r\n  absPath,\r\n  exportName, // string or \"default\"\r\n  t,\r\n  traverse,\r\n  parser,\r\n  RADIX_ROOTS,\r\n  depth = 0,\r\n  maxDepth = 3,\r\n}) {\r\n  if (!absPath || depth > maxDepth) return false;\r\n  const cacheKey = `${absPath}::${exportName}`;\r\n  if (PORTAL_COMP_CACHE.has(cacheKey)) return PORTAL_COMP_CACHE.get(cacheKey);\r\n\r\n  const ast = parseFileAst(absPath, parser);\r\n  if (!ast) {\r\n    PORTAL_COMP_CACHE.set(cacheKey, false);\r\n    return false;\r\n  }\r\n\r\n  // Map local imports -> file paths for recursive checks\r\n  const importMap = new Map(); // localName -> { absPath, importName }\r\n  traverse(ast, {\r\n    ImportDeclaration(p) {\r\n      const src = p.node.source.value;\r\n      const target = resolveImportPath(src, absPath);\r\n      if (!target) return;\r\n      p.node.specifiers.forEach((s) => {\r\n        if (t.isImportSpecifier(s)) {\r\n          importMap.set(s.local.name, {\r\n            absPath: target,\r\n            importName: s.imported.name,\r\n          });\r\n        } else if (t.isImportDefaultSpecifier(s)) {\r\n          importMap.set(s.local.name, {\r\n            absPath: target,\r\n            importName: \"default\",\r\n          });\r\n        }\r\n      });\r\n    },\r\n  });\r\n\r\n  // Find the component declaration for exportName\r\n  let compPaths = [];\r\n\r\n  traverse(ast, {\r\n    ExportDefaultDeclaration(p) {\r\n      if (exportName !== \"default\") return;\r\n      const decl = p.node.declaration;\r\n      if (\r\n        t.isFunctionDeclaration(decl) ||\r\n        t.isArrowFunctionExpression(decl) ||\r\n        t.isFunctionExpression(decl)\r\n      ) {\r\n        compPaths.push(p.get(\"declaration\"));\r\n      } else if (t.isIdentifier(decl)) {\r\n        const bind = p.scope.getBinding(decl.name);\r\n        if (bind) compPaths.push(bind.path);\r\n      }\r\n    },\r\n    ExportNamedDeclaration(p) {\r\n      if (exportName === \"default\") return;\r\n      if (p.node.declaration) {\r\n        const d = p.node.declaration;\r\n        if (t.isFunctionDeclaration(d) && d.id?.name === exportName) {\r\n          compPaths.push(p.get(\"declaration\"));\r\n        }\r\n        if (t.isVariableDeclaration(d)) {\r\n          d.declarations.forEach((vd, i) => {\r\n            if (t.isIdentifier(vd.id) && vd.id.name === exportName) {\r\n              compPaths.push(p.get(`declaration.declarations.${i}.init`));\r\n            }\r\n          });\r\n        }\r\n      } else {\r\n        p.node.specifiers.forEach((s) => {\r\n          if (\r\n            t.isExportSpecifier(s) &&\r\n            t.isIdentifier(s.exported) &&\r\n            s.exported.name === exportName &&\r\n            t.isIdentifier(s.local)\r\n          ) {\r\n            const bind = p.scope.getBinding(s.local.name);\r\n            if (bind) compPaths.push(bind.path);\r\n          }\r\n        });\r\n      }\r\n    },\r\n  });\r\n\r\n  if (compPaths.length === 0) {\r\n    PORTAL_COMP_CACHE.set(cacheKey, false);\r\n    return false;\r\n  }\r\n\r\n  let found = false;\r\n\r\n  function subtreeHasPortals(nodePath) {\r\n    let hit = false;\r\n    nodePath.traverse({\r\n      JSXOpeningElement(op) {\r\n        if (hit) return;\r\n        const name = jsxNameOf(op.node, t);\r\n        if (isPortalishName(name, RADIX_ROOTS)) {\r\n          hit = true;\r\n          return;\r\n        }\r\n        if (/^[A-Z]/.test(name || \"\")) {\r\n          // capitalized child: may itself be portalish\r\n          const binding = op.scope.getBinding(name);\r\n          if (binding && binding.path) {\r\n            const childHas = subtreeHasPortals(binding.path);\r\n            if (childHas) {\r\n              hit = true;\r\n              return;\r\n            }\r\n          } else if (importMap.has(name)) {\r\n            const { absPath: childPath, importName } = importMap.get(name);\r\n            const childHas = fileExportHasPortals({\r\n              absPath: childPath,\r\n              exportName: importName,\r\n              t,\r\n              traverse,\r\n              parser,\r\n              RADIX_ROOTS,\r\n              depth: depth + 1,\r\n            });\r\n            if (childHas) {\r\n              hit = true;\r\n              return;\r\n            }\r\n          }\r\n        }\r\n      },\r\n    });\r\n    return hit;\r\n  }\r\n\r\n  for (const pth of compPaths) {\r\n    if (!pth || !pth.node) continue;\r\n    if (subtreeHasPortals(pth)) {\r\n      found = true;\r\n      break;\r\n    }\r\n  }\r\n\r\n  PORTAL_COMP_CACHE.set(cacheKey, found);\r\n  return found;\r\n}\r\n\r\n// Decide at a usage site whether <ElementName /> is a composite that should be excluded\r\nfunction usageIsCompositePortal({\r\n  elementName,\r\n  jsxPath,\r\n  state,\r\n  t,\r\n  traverse,\r\n  parser,\r\n  RADIX_ROOTS,\r\n}) {\r\n  // Same-file binding?\r\n  const binding = jsxPath.scope.getBinding(elementName);\r\n  if (binding && binding.path) {\r\n    // Analyze the definition directly\r\n    let hit = false;\r\n    binding.path.traverse({\r\n      JSXOpeningElement(op) {\r\n        if (hit) return;\r\n        const name = jsxNameOf(op.node, t);\r\n        if (isPortalishName(name, RADIX_ROOTS)) {\r\n          hit = true;\r\n          return;\r\n        }\r\n        if (/^[A-Z]/.test(name || \"\")) {\r\n          const innerBinding = op.scope.getBinding(name);\r\n          if (innerBinding && innerBinding.path) {\r\n            innerBinding.path.traverse(this.visitors);\r\n          }\r\n        }\r\n      },\r\n    });\r\n    if (hit) return true;\r\n  }\r\n\r\n  // Imported binding (named)\r\n  if (binding && binding.path && binding.path.isImportSpecifier()) {\r\n    const from = binding.path.parent.source.value;\r\n    const fileFrom =\r\n      state.filename ||\r\n      state.file?.opts?.filename ||\r\n      state.file?.sourceFileName ||\r\n      __filename;\r\n    const absPath = resolveImportPath(from, fileFrom);\r\n    if (!absPath) return false;\r\n    const exportName = binding.path.node.imported.name;\r\n    return fileExportHasPortals({\r\n      absPath,\r\n      exportName,\r\n      t,\r\n      traverse,\r\n      parser,\r\n      RADIX_ROOTS,\r\n    });\r\n  }\r\n\r\n  // Imported binding (default)\r\n  if (binding && binding.path && binding.path.isImportDefaultSpecifier()) {\r\n    const from = binding.path.parent.source.value;\r\n    const fileFrom =\r\n      state.filename ||\r\n      state.file?.opts?.filename ||\r\n      state.file?.sourceFileName ||\r\n      __filename;\r\n    const absPath = resolveImportPath(from, fileFrom);\r\n    if (!absPath) return false;\r\n    return fileExportHasPortals({\r\n      absPath,\r\n      exportName: \"default\",\r\n      t,\r\n      traverse,\r\n      parser,\r\n      RADIX_ROOTS,\r\n    });\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n// ÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇÔöÇ\r\n// Babel plugin for JSX transformation - adds metadata to all elements\r\nconst babelMetadataPlugin = ({ types: t }) => {\r\n  const fileNameCache = new Map();\r\n\r\n  const ARRAY_METHODS = new Set([\r\n    \"map\",\r\n    \"forEach\",\r\n    \"filter\",\r\n    \"reduce\",\r\n    \"reduceRight\",\r\n    \"flatMap\",\r\n    \"find\",\r\n    \"findIndex\",\r\n    \"some\",\r\n    \"every\",\r\n  ]);\r\n\r\n  // ---------- helpers ----------\r\n  const getName = (openingEl) => {\r\n    const n = openingEl?.name;\r\n    return t.isJSXIdentifier(n) ? n.name : null;\r\n  };\r\n\r\n  const hasProp = (openingEl, name) =>\r\n    openingEl?.attributes?.some(\r\n      (a) =>\r\n        t.isJSXAttribute(a) &&\r\n        t.isJSXIdentifier(a.name) &&\r\n        a.name.name === name,\r\n    );\r\n\r\n  const isPortalPrimitive = (name) =>\r\n    /(Trigger|Portal|Content|Overlay|Viewport|Anchor|Arrow)$/.test(name);\r\n\r\n  const RADIX_ROOTS = new Set([\r\n    \"Dialog\",\r\n    \"Popover\",\r\n    \"Tooltip\",\r\n    \"DropdownMenu\",\r\n    \"ContextMenu\",\r\n    \"AlertDialog\",\r\n    \"HoverCard\",\r\n    \"Select\",\r\n    \"Menubar\",\r\n    \"NavigationMenu\",\r\n    \"Sheet\",\r\n    \"Drawer\",\r\n    \"Toast\",\r\n    \"Command\",\r\n  ]);\r\n\r\n  // direct child of a Trigger / asChild / Slot parent?\r\n  const isDirectChildOfAsChildOrTrigger = (jsxPath) => {\r\n    const p = jsxPath.parentPath;\r\n    if (!p || !p.isJSXElement || !p.isJSXElement()) return false;\r\n    const open = p.node.openingElement;\r\n    const name = getName(open) || \"\";\r\n    return hasProp(open, \"asChild\") || /Trigger$/.test(name) || name === \"Slot\";\r\n  };\r\n\r\n  const alreadyHasXMeta = (openingEl) =>\r\n    openingEl.attributes?.some(\r\n      (a) =>\r\n        t.isJSXAttribute(a) &&\r\n        t.isJSXIdentifier(a.name) &&\r\n        a.name.name.startsWith(\"x-\"),\r\n    );\r\n\r\n  // Ô¼ç´©Å Add { markExcluded } option: when true, include x-excluded=\"true\"\r\n  const insertMetaAttributes = (openingEl, attrsToAdd) => {\r\n    if (!openingEl.attributes) openingEl.attributes = [];\r\n    const spreadIndex = openingEl.attributes.findIndex((attr) =>\r\n      t.isJSXSpreadAttribute(attr),\r\n    );\r\n    if (spreadIndex === -1) {\r\n      openingEl.attributes.push(...attrsToAdd);\r\n    } else {\r\n      openingEl.attributes.splice(spreadIndex, 0, ...attrsToAdd);\r\n    }\r\n  };\r\n\r\n  const pushMetaAttrs = (\r\n    openingEl,\r\n    { normalizedPath, lineNumber, elementName, isDynamic },\r\n    { markExcluded = false } = {},\r\n  ) => {\r\n    if (alreadyHasXMeta(openingEl)) return;\r\n    const metaAttrs = [\r\n      t.jsxAttribute(\r\n        t.jsxIdentifier(\"x-file-name\"),\r\n        t.stringLiteral(normalizedPath),\r\n      ),\r\n      t.jsxAttribute(\r\n        t.jsxIdentifier(\"x-line-number\"),\r\n        t.stringLiteral(String(lineNumber)),\r\n      ),\r\n      t.jsxAttribute(\r\n        t.jsxIdentifier(\"x-component\"),\r\n        t.stringLiteral(elementName),\r\n      ),\r\n      t.jsxAttribute(\r\n        t.jsxIdentifier(\"x-id\"),\r\n        t.stringLiteral(`${normalizedPath}_${lineNumber}`),\r\n      ),\r\n      t.jsxAttribute(\r\n        t.jsxIdentifier(\"x-dynamic\"),\r\n        t.stringLiteral(isDynamic ? \"true\" : \"false\"),\r\n      ),\r\n    ];\r\n    if (markExcluded) {\r\n      metaAttrs.push(\r\n        t.jsxAttribute(t.jsxIdentifier(\"x-excluded\"), t.stringLiteral(\"true\")),\r\n      );\r\n    }\r\n    insertMetaAttributes(openingEl, metaAttrs);\r\n  };\r\n\r\n  // Check if a JSX element is inside an array iteration callback\r\n  function isJSXDynamic(jsxPath) {\r\n    // Use findParent to reliably check if we're inside a function callback to an array method\r\n    return !!jsxPath.findParent((path) => {\r\n      // Look for ArrowFunctionExpression or FunctionExpression\r\n      if (!path.isArrowFunctionExpression() && !path.isFunctionExpression()) {\r\n        return false;\r\n      }\r\n\r\n      // Check if parent is a CallExpression with an array method\r\n      const parentCall = path.parentPath;\r\n      if (!parentCall || !parentCall.isCallExpression()) {\r\n        return false;\r\n      }\r\n\r\n      const { callee } = parentCall.node;\r\n      if (!t.isMemberExpression(callee) || !t.isIdentifier(callee.property)) {\r\n        return false;\r\n      }\r\n\r\n      return ARRAY_METHODS.has(callee.property.name);\r\n    });\r\n  }\r\n\r\n  // Check if JSX element has any expressions (data dependencies)\r\n  function hasAnyExpression(jsxElement) {\r\n    const openingEl = jsxElement.openingElement;\r\n    if (openingEl?.attributes?.some((attr) => t.isJSXSpreadAttribute(attr))) {\r\n      return true;\r\n    }\r\n    for (const child of jsxElement.children) {\r\n      if (\r\n        t.isJSXExpressionContainer(child) &&\r\n        !t.isJSXEmptyExpression(child.expression)\r\n      ) {\r\n        return true;\r\n      }\r\n      if (t.isJSXSpreadChild(child)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // bring in parser/traverse for dynamic analysis\r\n  const parser = require(\"@babel/parser\");\r\n  const traverse = require(\"@babel/traverse\").default;\r\n\r\n  function pathHasDynamicJSX(targetPath) {\r\n    if (!targetPath || !targetPath.node) return false;\r\n    let dynamic = false;\r\n    targetPath.traverse({\r\n      JSXExpressionContainer(p) {\r\n        if (dynamic) return;\r\n        if (!t.isJSXEmptyExpression(p.node.expression)) {\r\n          dynamic = true;\r\n          p.stop();\r\n        }\r\n      },\r\n      JSXSpreadAttribute(p) {\r\n        if (dynamic) return;\r\n        dynamic = true;\r\n        p.stop();\r\n      },\r\n      JSXSpreadChild(p) {\r\n        if (dynamic) return;\r\n        dynamic = true;\r\n        p.stop();\r\n      },\r\n    });\r\n    return dynamic;\r\n  }\r\n\r\n  function pathIsDynamicComponent(path, visited = new WeakSet()) {\r\n    if (!path || !path.node) return false;\r\n    if (visited.has(path.node)) return false;\r\n    visited.add(path.node);\r\n\r\n    if (\r\n      path.isFunctionDeclaration() ||\r\n      path.isFunctionExpression() ||\r\n      path.isArrowFunctionExpression()\r\n    ) {\r\n      return pathHasDynamicJSX(path);\r\n    }\r\n\r\n    if (path.isVariableDeclarator()) {\r\n      const init = path.get(\"init\");\r\n      return init && init.node ? pathIsDynamicComponent(init, visited) : false;\r\n    }\r\n\r\n    if (path.isIdentifier()) {\r\n      const binding = path.scope.getBinding(path.node.name);\r\n      if (binding) {\r\n        return pathIsDynamicComponent(binding.path, visited);\r\n      }\r\n      return false;\r\n    }\r\n\r\n    if (path.isCallExpression()) {\r\n      const args = path.get(\"arguments\") || [];\r\n      if (args.length === 0) {\r\n        return true;\r\n      }\r\n      for (const arg of args) {\r\n        if (pathIsDynamicComponent(arg, visited)) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n\r\n    if (path.isReturnStatement()) {\r\n      const argument = path.get(\"argument\");\r\n      return argument && argument.node\r\n        ? pathIsDynamicComponent(argument, visited)\r\n        : false;\r\n    }\r\n\r\n    if (path.isExpressionStatement()) {\r\n      const expr = path.get(\"expression\");\r\n      return expr && expr.node ? pathIsDynamicComponent(expr, visited) : false;\r\n    }\r\n\r\n    if (path.isJSXElement() || path.isJSXFragment()) {\r\n      return pathHasDynamicJSX(path);\r\n    }\r\n\r\n    if (path.isObjectExpression()) {\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  function fileExportIsDynamic({ absPath, exportName }) {\r\n    if (!absPath) return false;\r\n    const cacheKey = `${absPath}::${exportName}`;\r\n    if (DYNAMIC_COMP_CACHE.has(cacheKey)) {\r\n      return DYNAMIC_COMP_CACHE.get(cacheKey);\r\n    }\r\n\r\n    const ast = parseFileAst(absPath, parser);\r\n    if (!ast) {\r\n      DYNAMIC_COMP_CACHE.set(cacheKey, false);\r\n      return false;\r\n    }\r\n\r\n    let dynamic = false;\r\n    const visited = new WeakSet();\r\n\r\n    function evaluatePath(nodePath) {\r\n      if (!nodePath || !nodePath.node || dynamic) return;\r\n      if (visited.has(nodePath.node)) return;\r\n      visited.add(nodePath.node);\r\n\r\n      if (\r\n        nodePath.isFunctionDeclaration() ||\r\n        nodePath.isFunctionExpression() ||\r\n        nodePath.isArrowFunctionExpression()\r\n      ) {\r\n        if (pathHasDynamicJSX(nodePath)) {\r\n          dynamic = true;\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (nodePath.isVariableDeclarator()) {\r\n        evaluatePath(nodePath.get(\"init\"));\r\n        return;\r\n      }\r\n\r\n      if (nodePath.isIdentifier()) {\r\n        const binding = nodePath.scope.getBinding(nodePath.node.name);\r\n        if (binding) {\r\n          evaluatePath(binding.path);\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (nodePath.isCallExpression()) {\r\n        const args = nodePath.get(\"arguments\") || [];\r\n        if (args.length === 0) {\r\n          dynamic = true;\r\n          return;\r\n        }\r\n        for (const arg of args) {\r\n          evaluatePath(arg);\r\n          if (dynamic) return;\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (nodePath.isReturnStatement()) {\r\n        evaluatePath(nodePath.get(\"argument\"));\r\n        return;\r\n      }\r\n\r\n      if (nodePath.isExpressionStatement()) {\r\n        evaluatePath(nodePath.get(\"expression\"));\r\n        return;\r\n      }\r\n\r\n      if (nodePath.isJSXElement() || nodePath.isJSXFragment()) {\r\n        if (pathHasDynamicJSX(nodePath)) {\r\n          dynamic = true;\r\n        }\r\n        return;\r\n      }\r\n\r\n      if (nodePath.isObjectExpression()) {\r\n        dynamic = true;\r\n      }\r\n    }\r\n\r\n    traverse(ast, {\r\n      ExportDefaultDeclaration(p) {\r\n        if (dynamic || exportName !== \"default\") return;\r\n        evaluatePath(p.get(\"declaration\"));\r\n      },\r\n      ExportNamedDeclaration(p) {\r\n        if (dynamic || exportName === \"default\") return;\r\n\r\n        if (p.node.declaration) {\r\n          const decl = p.node.declaration;\r\n          if (t.isFunctionDeclaration(decl) && decl.id?.name === exportName) {\r\n            evaluatePath(p.get(\"declaration\"));\r\n            return;\r\n          }\r\n          if (t.isVariableDeclaration(decl)) {\r\n            decl.declarations.forEach((vd, i) => {\r\n              if (t.isIdentifier(vd.id) && vd.id.name === exportName) {\r\n                evaluatePath(p.get(`declaration.declarations.${i}`));\r\n              }\r\n            });\r\n            return;\r\n          }\r\n        }\r\n\r\n        p.node.specifiers.forEach((s) => {\r\n          if (\r\n            !t.isExportSpecifier(s) ||\r\n            !t.isIdentifier(s.exported) ||\r\n            s.exported.name !== exportName\r\n          ) {\r\n            return;\r\n          }\r\n\r\n          if (p.node.source) {\r\n            const from = p.node.source.value;\r\n            const resolved = resolveImportPath(from, absPath);\r\n            if (resolved) {\r\n              if (\r\n                fileExportIsDynamic({\r\n                  absPath: resolved,\r\n                  exportName: t.isIdentifier(s.local)\r\n                    ? s.local.name\r\n                    : exportName,\r\n                })\r\n              ) {\r\n                dynamic = true;\r\n              }\r\n            }\r\n            return;\r\n          }\r\n\r\n          if (t.isIdentifier(s.local)) {\r\n            const binding = p.scope.getBinding(s.local.name);\r\n            if (binding) {\r\n              evaluatePath(binding.path);\r\n            }\r\n          }\r\n        });\r\n      },\r\n    });\r\n\r\n    DYNAMIC_COMP_CACHE.set(cacheKey, dynamic);\r\n    return dynamic;\r\n  }\r\n\r\n  function componentBindingIsDynamic({ binding, state }) {\r\n    if (!binding || !binding.path) return false;\r\n    const bindingPath = binding.path;\r\n\r\n    if (BINDING_DYNAMIC_CACHE.has(bindingPath.node)) {\r\n      return BINDING_DYNAMIC_CACHE.get(bindingPath.node);\r\n    }\r\n\r\n    let result = false;\r\n\r\n    if (bindingPath.isImportSpecifier()) {\r\n      const from = bindingPath.parent.source.value;\r\n      const fileFrom =\r\n        state.filename ||\r\n        state.file?.opts?.filename ||\r\n        state.file?.sourceFileName ||\r\n        __filename;\r\n      const absPath = resolveImportPath(from, fileFrom);\r\n      const exportName = bindingPath.node.imported.name;\r\n      result = !!absPath ? fileExportIsDynamic({ absPath, exportName }) : false;\r\n      BINDING_DYNAMIC_CACHE.set(bindingPath.node, result);\r\n      return result;\r\n    }\r\n\r\n    if (bindingPath.isImportDefaultSpecifier()) {\r\n      const from = bindingPath.parent.source.value;\r\n      const fileFrom =\r\n        state.filename ||\r\n        state.file?.opts?.filename ||\r\n        state.file?.sourceFileName ||\r\n        __filename;\r\n      const absPath = resolveImportPath(from, fileFrom);\r\n      result = !!absPath\r\n        ? fileExportIsDynamic({ absPath, exportName: \"default\" })\r\n        : false;\r\n      BINDING_DYNAMIC_CACHE.set(bindingPath.node, result);\r\n      return result;\r\n    }\r\n\r\n    if (bindingPath.isImportNamespaceSpecifier()) {\r\n      BINDING_DYNAMIC_CACHE.set(bindingPath.node, false);\r\n      return false;\r\n    }\r\n\r\n    result = pathIsDynamicComponent(bindingPath);\r\n    BINDING_DYNAMIC_CACHE.set(bindingPath.node, result);\r\n    return result;\r\n  }\r\n\r\n  return {\r\n    name: \"element-metadata-plugin\",\r\n    visitor: {\r\n      // Add metadata attributes to React components (capitalized JSX)\r\n      JSXElement(jsxPath, state) {\r\n        const openingElement = jsxPath.node.openingElement;\r\n        if (!openingElement?.name) return;\r\n        const elementName = getName(openingElement);\r\n        if (!elementName) return;\r\n\r\n        // Only process capitalized components (React components)\r\n        if (!/^[A-Z]/.test(elementName)) return;\r\n\r\n        // Exclude components that have strict child requirements or break when wrapped\r\n        const excludedComponents = new Set([\r\n          \"Route\",\r\n          \"Routes\",\r\n          \"Switch\",\r\n          \"Redirect\",\r\n          \"Navigate\", // React Router\r\n          \"Fragment\",\r\n          \"Suspense\",\r\n          \"StrictMode\", // React built-ins\r\n          \"ErrorBoundary\",\r\n          \"Provider\",\r\n          \"Consumer\",\r\n          \"Outlet\",\r\n          \"Link\",\r\n          \"NavLink\",\r\n          // Portal-based primitives/triggers (Radix/Floating-UI)\r\n          \"Sheet\",\r\n          \"SheetContent\",\r\n          \"SheetOverlay\",\r\n          \"SheetPortal\",\r\n          \"Popover\",\r\n          \"PopoverContent\",\r\n          \"Tooltip\",\r\n          \"TooltipContent\",\r\n          \"DropdownMenu\",\r\n          \"DropdownMenuContent\",\r\n          \"DropdownMenuSubContent\",\r\n          \"ContextMenu\",\r\n          \"ContextMenuContent\",\r\n          \"ContextMenuSubContent\",\r\n          \"HoverCard\",\r\n          \"HoverCardContent\",\r\n          \"Select\",\r\n          \"SelectContent\",\r\n          \"Menubar\",\r\n          \"MenubarContent\",\r\n          \"MenubarSubContent\",\r\n          \"MenubarPortal\",\r\n          \"Drawer\",\r\n          \"DrawerContent\",\r\n          \"DrawerOverlay\",\r\n          \"DrawerPortal\",\r\n          \"Toast\",\r\n          \"ToastViewport\",\r\n          \"NavigationMenu\",\r\n          \"NavigationMenuContent\",\r\n          \"DropdownMenuPortal\",\r\n          \"ContextMenuPortal\",\r\n          \"Command\",\r\n          \"CommandDialog\",\r\n          // Triggers & measured bits\r\n          \"PopoverTrigger\",\r\n          \"TooltipTrigger\",\r\n          \"DropdownMenuTrigger\",\r\n          \"ContextMenuTrigger\",\r\n          \"HoverCardTrigger\",\r\n          \"SelectTrigger\",\r\n          \"MenubarTrigger\",\r\n          \"NavigationMenuTrigger\",\r\n          \"SheetTrigger\",\r\n          \"DrawerTrigger\",\r\n          \"CommandInput\",\r\n          \"Slot\",\r\n          // icons (avoid wrapping)\r\n          \"X\",\r\n          \"ChevronRight\",\r\n          \"ChevronLeft\",\r\n          \"ChevronUp\",\r\n          \"ChevronDown\",\r\n          \"Check\",\r\n          \"Plus\",\r\n          \"Minus\",\r\n          \"Search\",\r\n          \"Menu\",\r\n          \"Settings\",\r\n          \"User\",\r\n          \"Home\",\r\n          \"ArrowRight\",\r\n          \"ArrowLeft\",\r\n        ]);\r\n        if (excludedComponents.has(elementName)) return;\r\n\r\n        // Check if parent is a component that strictly validates children\r\n        const parent = jsxPath.parentPath;\r\n        if (parent?.isJSXElement?.()) {\r\n          const parentName = getName(parent.node.openingElement) || \"\";\r\n          if (\r\n            [\r\n              \"Routes\",\r\n              \"Switch\",\r\n              \"BrowserRouter\",\r\n              \"Router\",\r\n              \"MemoryRouter\",\r\n              \"HashRouter\",\r\n            ].includes(parentName) ||\r\n            RADIX_ROOTS.has(parentName)\r\n          ) {\r\n            // Don't wrap if direct child of strict parent (e.g., Route inside Routes, or Radix roots)\r\n            return;\r\n          }\r\n        }\r\n\r\n        // Get source location\r\n        const filename =\r\n          state.filename ||\r\n          state.file?.opts?.filename ||\r\n          state.file?.sourceFileName ||\r\n          \"unknown\";\r\n        const lineNumber = openingElement.loc?.start.line || 0;\r\n\r\n        if (!fileNameCache.has(filename)) {\r\n          const base = path.basename(filename).replace(/\\.[jt]sx?$/, \"\");\r\n          fileNameCache.set(filename, base);\r\n        }\r\n        const normalizedPath = fileNameCache.get(filename) || \"unknown\";\r\n\r\n        // Detect dynamic\r\n        let isDynamic = isJSXDynamic(jsxPath) || hasAnyExpression(jsxPath.node);\r\n\r\n        // Only check component definition if there are NO static text children.\r\n        // If there ARE text children (like <Label>Habit Name</Label>), their editability\r\n        // depends on whether they're static strings, not on the component's internal implementation.\r\n        if (!isDynamic) {\r\n          const hasStaticTextChildren = jsxPath.node.children.some(\r\n            (child) => t.isJSXText(child) && child.value.trim()\r\n          );\r\n          if (!hasStaticTextChildren) {\r\n            const binding = jsxPath.scope.getBinding(elementName);\r\n            if (binding) {\r\n              isDynamic = componentBindingIsDynamic({ binding, state });\r\n            }\r\n          }\r\n        }\r\n\r\n        // Check if parent is a detected composite portal\r\n        const parentIsCompositePortal = (() => {\r\n          const p = jsxPath.parentPath;\r\n          if (!p || !p.isJSXElement || !p.isJSXElement()) return false;\r\n          const parentName = getName(p.node.openingElement);\r\n          if (!parentName || !/^[A-Z]/.test(parentName)) return false;\r\n\r\n          // Check if parent was detected as composite portal\r\n          return usageIsCompositePortal({\r\n            elementName: parentName,\r\n            jsxPath: p,\r\n            state,\r\n            t,\r\n            traverse,\r\n            parser,\r\n            RADIX_ROOTS,\r\n          });\r\n        })();\r\n\r\n        // ­şÜ½ If this element is a direct child of a Trigger/asChild/Slot,\r\n        // or itself a primitive/root, DO NOT WRAP ÔÇö stamp x-* on the element itself\r\n        // and mark it with x-excluded=\"true\".\r\n        if (\r\n          hasProp(openingElement, \"asChild\") ||\r\n          isPortalPrimitive(elementName) ||\r\n          RADIX_ROOTS.has(elementName) ||\r\n          isDirectChildOfAsChildOrTrigger(jsxPath) ||\r\n          parentIsCompositePortal\r\n        ) {\r\n          pushMetaAttrs(\r\n            openingElement,\r\n            { normalizedPath, lineNumber, elementName, isDynamic },\r\n            { markExcluded: true },\r\n          );\r\n          return;\r\n        }\r\n\r\n        // NEW: dynamic composite detection (e.g., DemoPopover renders Popover primitives)\r\n        const compositePortal = usageIsCompositePortal({\r\n          elementName,\r\n          jsxPath,\r\n          state,\r\n          t,\r\n          traverse,\r\n          parser,\r\n          RADIX_ROOTS,\r\n        });\r\n\r\n        if (compositePortal) {\r\n          // Composite portal: stamp + mark excluded\r\n          pushMetaAttrs(\r\n            openingElement,\r\n            { normalizedPath, lineNumber, elementName, isDynamic },\r\n            { markExcluded: true },\r\n          );\r\n          return;\r\n        }\r\n\r\n        // Ô£à Normal case: add metadata attributes directly\r\n        pushMetaAttrs(\r\n          openingElement,\r\n          { normalizedPath, lineNumber, elementName, isDynamic },\r\n        );\r\n      },\r\n\r\n      // Add metadata to native HTML elements (lowercase JSX)\r\n      JSXOpeningElement(jsxPath, state) {\r\n        if (!jsxPath.node.name || !jsxPath.node.name.name) {\r\n          return;\r\n        }\r\n\r\n        const elementName = jsxPath.node.name.name;\r\n\r\n        // Skip fragments\r\n        if (elementName === \"Fragment\") {\r\n          return;\r\n        }\r\n\r\n        // Only process lowercase (native HTML)\r\n        if (/^[A-Z]/.test(elementName)) {\r\n          return;\r\n        }\r\n\r\n        // Skip if already has metadata\r\n        const hasDebugAttr = jsxPath.node.attributes.some(\r\n          (attr) =>\r\n            t.isJSXAttribute(attr) &&\r\n            attr.name &&\r\n            attr.name.name &&\r\n            attr.name.name.startsWith(\"x-\"),\r\n        );\r\n        if (hasDebugAttr) return;\r\n\r\n        // Get source location\r\n        const filename =\r\n          state.filename ||\r\n          state.file?.opts?.filename ||\r\n          state.file?.sourceFileName ||\r\n          \"unknown\";\r\n\r\n        const lineNumber = jsxPath.node.loc?.start.line || 0;\r\n\r\n        if (!fileNameCache.has(filename)) {\r\n          const base = path.basename(filename).replace(/\\.[jt]sx?$/, \"\");\r\n          fileNameCache.set(filename, base);\r\n        }\r\n        const normalizedPath = fileNameCache.get(filename) || \"unknown\";\r\n\r\n        // Detect if native element is dynamic:\r\n        // 1. Inside an array iteration (.map(), etc.)\r\n        // 2. Has expression children (like {variable} or {obj.prop})\r\n        const parentElement = jsxPath.parentPath; // JSXElement containing this opening element\r\n        const isInArrayMethod = parentElement ? isJSXDynamic(parentElement) : false;\r\n        const hasExpressions = parentElement && parentElement.node ? hasAnyExpression(parentElement.node) : false;\r\n        const isDynamic = isInArrayMethod || hasExpressions;\r\n\r\n        // Add metadata attributes\r\n        insertMetaAttributes(jsxPath.node, [\r\n          t.jsxAttribute(\r\n            t.jsxIdentifier(\"x-file-name\"),\r\n            t.stringLiteral(normalizedPath),\r\n          ),\r\n          t.jsxAttribute(\r\n            t.jsxIdentifier(\"x-line-number\"),\r\n            t.stringLiteral(String(lineNumber)),\r\n          ),\r\n          t.jsxAttribute(\r\n            t.jsxIdentifier(\"x-component\"),\r\n            t.stringLiteral(elementName),\r\n          ),\r\n          t.jsxAttribute(\r\n            t.jsxIdentifier(\"x-id\"),\r\n            t.stringLiteral(`${normalizedPath}_${lineNumber}`),\r\n          ),\r\n          t.jsxAttribute(\r\n            t.jsxIdentifier(\"x-dynamic\"),\r\n            t.stringLiteral(isDynamic ? \"true\" : \"false\"),\r\n          ),\r\n        ]);\r\n      },\r\n    },\r\n  };\r\n};\r\n\r\nmodule.exports = babelMetadataPlugin;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arda\\.gemini\\antigravity\\scratch\\restin-ai\\frontend\\plugins\\visual-edits\\dev-server-setup.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'err' is defined but never used.","line":143,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":143,"endColumn":25},{"ruleId":"no-unused-vars","severity":1,"message":"'parseError' is defined but never used.","line":239,"column":22,"nodeType":"Identifier","messageId":"unusedVar","endLine":239,"endColumn":32}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// dev-server-setup.js\r\n// Dev server middleware configuration for visual editing\r\nconst fs = require(\"fs\");\r\nconst path = require(\"path\");\r\nconst express = require(\"express\");\r\nconst { execSync } = require(\"child_process\");\r\n\r\n// ­şöı Read Supervisor code-server password from conf.d\r\nfunction getCodeServerPassword() {\r\n  try {\r\n    const conf = fs.readFileSync(\r\n      \"/etc/supervisor/conf.d/supervisord_code_server.conf\",\r\n      \"utf8\",\r\n    );\r\n\r\n    // Match environment=PASSWORD=\"value\"\r\n    const match = conf.match(/PASSWORD=\"([^\"]+)\"/);\r\n    return match ? match[1] : null;\r\n  } catch {\r\n    return null;\r\n  }\r\n}\r\n\r\nconst SUP_PASS = getCodeServerPassword();\r\n\r\n// Dev server setup function\r\nfunction setupDevServer(config) {\r\n  config.setupMiddlewares = (middlewares, devServer) => {\r\n    if (!devServer) throw new Error(\"webpack-dev-server not defined\");\r\n    devServer.app.use(express.json());\r\n\r\n    // CORS origin validation\r\n    const isAllowedOrigin = (origin) => {\r\n      if (!origin) return false;\r\n\r\n      // Allow localhost and 127.0.0.1 on any port\r\n      if (origin.match(/^https?:\\/\\/(localhost|127\\.0\\.0\\.1)(:\\d+)?$/)) {\r\n        return true;\r\n      }\r\n\r\n      // Allow all emergent.sh subdomains\r\n      if (origin.match(/^https:\\/\\/([a-zA-Z0-9-]+\\.)*emergent\\.sh$/)) {\r\n        return true;\r\n      }\r\n\r\n      // Allow all emergentagent.com subdomains\r\n      if (origin.match(/^https:\\/\\/([a-zA-Z0-9-]+\\.)*emergentagent\\.com$/)) {\r\n        return true;\r\n      }\r\n\r\n      // Allow all appspot.com subdomains (for App Engine)\r\n      if (origin.match(/^https:\\/\\/([a-zA-Z0-9-]+\\.)*appspot\\.com$/)) {\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    };\r\n\r\n    // Ô£à Health check (no auth)\r\n    devServer.app.get(\"/ping\", (req, res) => {\r\n      res.json({ status: \"ok\", time: new Date().toISOString() });\r\n    });\r\n\r\n    // Ô£à Protected file editing endpoint with AST processing\r\n    devServer.app.post(\"/edit-file\", (req, res) => {\r\n      // Validate and set CORS headers\r\n      const origin = req.get(\"Origin\");\r\n      if (origin && isAllowedOrigin(origin)) {\r\n        res.header(\"Access-Control-Allow-Origin\", origin);\r\n        res.header(\"Access-Control-Allow-Headers\", \"Content-Type, x-api-key\");\r\n      }\r\n\r\n      // ­şöæ Check header against Supervisor password\r\n      const key = req.get(\"x-api-key\");\r\n      if (!SUP_PASS || key !== SUP_PASS) {\r\n        return res.status(401).json({ error: \"Unauthorized\" });\r\n      }\r\n\r\n      const { changes } = req.body;\r\n\r\n      if (!changes || !Array.isArray(changes) || changes.length === 0) {\r\n        return res.status(400).json({ error: \"No changes provided\" });\r\n      }\r\n\r\n      try {\r\n        // Track all edits for response\r\n        const edits = [];\r\n        const rejectedChanges = [];\r\n\r\n        // Group changes by fileName\r\n        const changesByFile = {};\r\n        changes.forEach((change) => {\r\n          if (!changesByFile[change.fileName]) {\r\n            changesByFile[change.fileName] = [];\r\n          }\r\n          changesByFile[change.fileName].push(change);\r\n        });\r\n\r\n        // Process each file's changes\r\n        Object.entries(changesByFile).forEach(([fileName, fileChanges]) => {\r\n          // Recursively search for the file in the frontend folder\r\n          const frontendRoot = path.resolve(__dirname, '../..');\r\n\r\n          // Helper function to get consistent relative path\r\n          const getRelativePath = (absolutePath) => {\r\n            const rel = path.relative(frontendRoot, absolutePath);\r\n            // Ensure it starts with / for consistency\r\n            return '/' + rel;\r\n          };\r\n\r\n          const findFileRecursive = (dir, filename) => {\r\n            try {\r\n              const files = fs.readdirSync(dir, { withFileTypes: true });\r\n\r\n              for (const file of files) {\r\n                const fullPath = path.join(dir, file.name);\r\n\r\n                // Skip excluded directories\r\n                if (file.isDirectory()) {\r\n                  if (\r\n                    file.name === \"node_modules\" ||\r\n                    file.name === \"public\" ||\r\n                    file.name === \".git\" ||\r\n                    file.name === \"build\" ||\r\n                    file.name === \"dist\" ||\r\n                    file.name === \"coverage\"\r\n                  ) {\r\n                    continue;\r\n                  }\r\n                  const found = findFileRecursive(fullPath, filename);\r\n                  if (found) return found;\r\n                } else if (file.isFile()) {\r\n                  // Check if filename matches (basename without extension)\r\n                  const fileBaseName = file.name.replace(\r\n                    /\\.(js|jsx|ts|tsx)$/,\r\n                    \"\",\r\n                  );\r\n                  if (fileBaseName === filename) {\r\n                    return fullPath;\r\n                  }\r\n                }\r\n              }\r\n            } catch (err) {\r\n              // Ignore permission errors and continue\r\n            }\r\n            return null;\r\n          };\r\n\r\n          // Find the file\r\n          let targetFile = findFileRecursive(frontendRoot, fileName);\r\n\r\n          // If still not found, default to components path with .js for new files\r\n          if (!targetFile) {\r\n            targetFile = path.resolve(\r\n              frontendRoot,\r\n              \"src/components\",\r\n              `${fileName}.js`,\r\n            );\r\n          }\r\n\r\n          // Security check - prevent path traversal and restrict to frontend folder\r\n          const normalizedTarget = path.normalize(targetFile);\r\n          const isInFrontend =\r\n            normalizedTarget.startsWith(frontendRoot) &&\r\n            !normalizedTarget.includes(\"..\");\r\n          const isNodeModules = normalizedTarget.includes(\"node_modules\");\r\n          const isPublic =\r\n            normalizedTarget.includes(\"/public/\") ||\r\n            normalizedTarget.endsWith(\"/public\");\r\n\r\n          if (!isInFrontend || isNodeModules || isPublic) {\r\n            throw new Error(`Forbidden path for file ${fileName}`);\r\n          }\r\n          // Import Babel libraries\r\n          const parser = require(\"@babel/parser\");\r\n          const traverse = require(\"@babel/traverse\").default;\r\n          const generate = require(\"@babel/generator\").default;\r\n          const t = require(\"@babel/types\");\r\n\r\n          // Verify file exists before attempting to read\r\n          if (!fs.existsSync(targetFile)) {\r\n            throw new Error(`File not found: ${targetFile}`);\r\n          }\r\n\r\n          // Read the current file content\r\n          const currentContent = fs.readFileSync(targetFile, \"utf8\");\r\n\r\n          // Parse the JSX file\r\n          const ast = parser.parse(currentContent, {\r\n            sourceType: \"module\",\r\n            plugins: [\"jsx\", \"typescript\"],\r\n          });\r\n\r\n          // Helper function to parse JSX children\r\n          const parseJsxChildren = (content) => {\r\n            if (content === undefined) {\r\n              return null;\r\n            }\r\n\r\n            const sanitizeMetaAttributes = (node) => {\r\n              if (t.isJSXElement(node)) {\r\n                node.openingElement.attributes =\r\n                  node.openingElement.attributes.filter((attr) => {\r\n                    if (\r\n                      t.isJSXAttribute(attr) &&\r\n                      t.isJSXIdentifier(attr.name)\r\n                    ) {\r\n                      return !attr.name.name.startsWith(\"x-\");\r\n                    }\r\n                    return true;\r\n                  });\r\n\r\n                node.children.forEach((child) =>\r\n                  sanitizeMetaAttributes(child),\r\n                );\r\n              } else if (t.isJSXFragment(node)) {\r\n                node.children.forEach((child) =>\r\n                  sanitizeMetaAttributes(child),\r\n                );\r\n              }\r\n            };\r\n\r\n            try {\r\n              const wrapperExpression = parser.parseExpression(\r\n                `(<gjs-wrapper>${content}</gjs-wrapper>)`,\r\n                {\r\n                  sourceType: \"module\",\r\n                  plugins: [\"jsx\", \"typescript\"],\r\n                },\r\n              );\r\n\r\n              if (t.isJSXElement(wrapperExpression)) {\r\n                const innerChildren = wrapperExpression.children || [];\r\n                innerChildren.forEach((child) =>\r\n                  sanitizeMetaAttributes(child),\r\n                );\r\n                return innerChildren;\r\n              }\r\n            } catch (parseError) {\r\n              // Fallback to treating content as raw text if parsing fails\r\n            }\r\n\r\n            return [t.jsxText(content)];\r\n          };\r\n\r\n          // Create a map of changes by line number for this file (array of changes per line)\r\n          const changesByLine = {};\r\n          fileChanges.forEach((change) => {\r\n            if (!changesByLine[change.lineNumber]) {\r\n              changesByLine[change.lineNumber] = [];\r\n            }\r\n            changesByLine[change.lineNumber].push(change);\r\n          });\r\n\r\n          // Traverse and update AST using line numbers\r\n          traverse(ast, {\r\n            JSXOpeningElement: (path) => {\r\n              const lineNumber = path.node.loc?.start.line;\r\n              if (!lineNumber) return;\r\n\r\n              const changesAtLine = changesByLine[lineNumber];\r\n              if (!changesAtLine || changesAtLine.length === 0) return;\r\n\r\n              // Verify this is the correct element by checking component type\r\n              const elementName = path.node.name.name;\r\n\r\n              // Process ALL changes for this line\r\n              changesAtLine.forEach((change) => {\r\n                if (elementName !== change.component) return;\r\n\r\n                // FIXED: Conditional processing based on change type\r\n                console.log(\r\n                  `[backend] Processing change type: ${change.type || \"legacy\"} for element: ${elementName}`,\r\n                );\r\n\r\n                if (\r\n                  change.type === \"className\" &&\r\n                  change.className !== undefined\r\n                ) {\r\n                  // CLASSNAME/TAILWIND PROCESSING\r\n                  console.log(\r\n                    `[backend] Processing className change:`,\r\n                    change.className,\r\n                  );\r\n\r\n                  // Find existing className attribute\r\n                  let classAttr = path.node.attributes.find(\r\n                    (attr) =>\r\n                      t.isJSXAttribute(attr) &&\r\n                      attr.name.name === \"className\",\r\n                  );\r\n\r\n                  // Capture old className value\r\n                  const oldClassName = classAttr?.value?.value || \"\";\r\n\r\n                  if (classAttr) {\r\n                    // Update existing className\r\n                    console.log(\r\n                      `[backend] Updating existing className from:`,\r\n                      classAttr.value?.value,\r\n                      \"to:\",\r\n                      change.className,\r\n                    );\r\n                    classAttr.value = t.stringLiteral(change.className);\r\n                  } else {\r\n                    // Create new className attribute\r\n                    console.log(\r\n                      `[backend] Creating new className attribute:`,\r\n                      change.className,\r\n                    );\r\n                    const newClassAttr = t.jsxAttribute(\r\n                      t.jsxIdentifier(\"className\"),\r\n                      t.stringLiteral(change.className),\r\n                    );\r\n                    path.node.attributes.push(newClassAttr);\r\n                  }\r\n\r\n                  // Track this edit\r\n                  edits.push({\r\n                    file: getRelativePath(targetFile),\r\n                    lineNumber: lineNumber,\r\n                    element: elementName,\r\n                    type: \"className\",\r\n                    oldData: oldClassName,\r\n                    newData: change.className,\r\n                  });\r\n                } else if (\r\n                  change.type === \"textContent\" &&\r\n                  change.textContent !== undefined\r\n                ) {\r\n                  console.log(\r\n                    `[backend] Processing textContent change:`,\r\n                    change.textContent,\r\n                  );\r\n\r\n                  const parentElementPath = path.parentPath;\r\n                  if (parentElementPath && parentElementPath.isJSXElement()) {\r\n                    const jsxElementNode = parentElementPath.node;\r\n                    const children = jsxElementNode.children || [];\r\n\r\n                    let targetTextNode = null;\r\n                    for (const child of children) {\r\n                      if (t.isJSXText(child) && child.value.trim().length > 0) {\r\n                        targetTextNode = child;\r\n                        break;\r\n                      }\r\n                    }\r\n\r\n                    const firstTextNode = targetTextNode;\r\n                    const fallbackWhitespaceNode = children.find(\r\n                      (child) => t.isJSXText(child) && child.value.trim().length === 0,\r\n                    );\r\n\r\n                    const newContent = change.textContent;\r\n                    let oldContent = \"\";\r\n\r\n                    const preserveWhitespace = (originalValue, updatedCore) => {\r\n                      const leadingWhitespace =\r\n                        (originalValue.match(/^\\s*/) || [\"\"])[0];\r\n                      const trailingWhitespace =\r\n                        (originalValue.match(/\\s*$/) || [\"\"])[0];\r\n                      return `${leadingWhitespace}${updatedCore}${trailingWhitespace}`;\r\n                    };\r\n\r\n                    if (firstTextNode) {\r\n                      oldContent = firstTextNode.value.trim();\r\n                      firstTextNode.value = preserveWhitespace(\r\n                        firstTextNode.value,\r\n                        newContent,\r\n                      );\r\n                    } else if (fallbackWhitespaceNode) {\r\n                      oldContent = \"\";\r\n                      fallbackWhitespaceNode.value = preserveWhitespace(\r\n                        fallbackWhitespaceNode.value,\r\n                        newContent,\r\n                      );\r\n                    } else {\r\n                      oldContent = \"\";\r\n                      const newTextNode = t.jsxText(newContent);\r\n                      jsxElementNode.children = [newTextNode, ...children];\r\n                    }\r\n\r\n                    edits.push({\r\n                      file: getRelativePath(targetFile),\r\n                      lineNumber: lineNumber,\r\n                      element: elementName,\r\n                      type: \"textContent\",\r\n                      oldData: oldContent,\r\n                      newData: newContent,\r\n                    });\r\n                  }\r\n                } else if (\r\n                  change.type === \"content\" &&\r\n                  change.content !== undefined\r\n                ) {\r\n                  // CONTENT-ONLY PROCESSING\r\n                  console.log(\r\n                    `[backend] Processing content-only change:`,\r\n                    change.content.slice(0, 100),\r\n                  );\r\n\r\n                  const parentElementPath = path.parentPath;\r\n                  if (parentElementPath && parentElementPath.isJSXElement()) {\r\n                    // Capture old content before modifying\r\n                    const oldChildren = parentElementPath.node.children || [];\r\n                    const generate = require(\"@babel/generator\").default;\r\n                    const oldContentAST = {\r\n                      type: \"JSXFragment\",\r\n                      children: oldChildren,\r\n                    };\r\n                    const oldContent = generate(oldContentAST, {}, \"\")\r\n                      .code.replace(/^<>/, \"\")\r\n                      .replace(/<\\/>$/, \"\")\r\n                      .trim();\r\n\r\n                    const newChildren = parseJsxChildren(change.content);\r\n                    if (newChildren) {\r\n                      parentElementPath.node.children = newChildren;\r\n                    }\r\n\r\n                    // Track this edit\r\n                    edits.push({\r\n                      file: getRelativePath(targetFile),\r\n                      lineNumber: lineNumber,\r\n                      element: elementName,\r\n                      type: \"content\",\r\n                      oldData: oldContent,\r\n                      newData: change.content,\r\n                    });\r\n                  }\r\n                } else {\r\n                  // Track rejected change\r\n                  const reason = `Change must have valid type ('className', 'textContent', or 'content'). Received type: ${change.type || 'undefined'}`;\r\n                  rejectedChanges.push({\r\n                    change,\r\n                    reason,\r\n                    file: getRelativePath(targetFile),\r\n                    lineNumber: lineNumber,\r\n                    element: elementName,\r\n                  });\r\n\r\n                  // Still log for debugging\r\n                  console.error(`[backend] REJECTED: ${reason}`, change);\r\n                  console.error(\r\n                    `[backend] This change will be IGNORED to prevent contamination.`,\r\n                  );\r\n                }\r\n              });\r\n\r\n              // Mark all changes at this line as processed\r\n              delete changesByLine[lineNumber];\r\n            },\r\n          });\r\n\r\n          // Generate updated code\r\n          const { code } = generate(ast, {\r\n            retainLines: true,\r\n            retainFunctionParens: true,\r\n            comments: true,\r\n          });\r\n\r\n          // Optional: Create backup before writing\r\n          const backupFile = targetFile + \".backup\";\r\n          if (fs.existsSync(targetFile)) {\r\n            const originalContent = fs.readFileSync(targetFile, \"utf8\");\r\n            fs.writeFileSync(backupFile, originalContent, \"utf8\");\r\n          }\r\n\r\n          // Write the updated content\r\n          fs.writeFileSync(targetFile, code, \"utf8\");\r\n\r\n          // Commit changes to git with timestamp\r\n          const timestamp = Date.now();\r\n          try {\r\n            // Use -c flag for per-invocation git config to avoid modifying any config\r\n            execSync(`git -c user.name=\"visual-edit\" -c user.email=\"support@emergent.sh\" add \"${targetFile}\"`);\r\n            execSync(`git -c user.name=\"visual-edit\" -c user.email=\"support@emergent.sh\" commit -m \"visual_edit_${timestamp}\"`);\r\n          } catch (gitError) {\r\n            console.error(`Git commit failed: ${gitError.message}`);\r\n            // Continue even if git fails - file write succeeded\r\n          }\r\n\r\n          // Clean up backup file after successful write and commit\r\n          if (fs.existsSync(backupFile)) {\r\n            fs.unlinkSync(backupFile);\r\n          }\r\n        });\r\n\r\n        const response = { status: \"ok\", edits };\r\n        if (rejectedChanges.length > 0) {\r\n          response.rejectedChanges = rejectedChanges;\r\n        }\r\n        res.json(response);\r\n      } catch (err) {\r\n        res.status(500).json({ error: err.message });\r\n      }\r\n    });\r\n\r\n    // Add OPTIONS handler for CORS preflight\r\n    devServer.app.options(\"/edit-file\", (req, res) => {\r\n      const origin = req.get(\"Origin\");\r\n      if (origin && isAllowedOrigin(origin)) {\r\n        res.header(\"Access-Control-Allow-Origin\", origin);\r\n        res.header(\"Access-Control-Allow-Methods\", \"POST, OPTIONS\");\r\n        res.header(\"Access-Control-Allow-Headers\", \"Content-Type, x-api-key\");\r\n        res.sendStatus(200);\r\n      } else {\r\n        res.sendStatus(403);\r\n      }\r\n    });\r\n\r\n    return middlewares;\r\n  };\r\n  return config;\r\n}\r\n\r\nmodule.exports = setupDevServer;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arda\\.gemini\\antigravity\\scratch\\restin-ai\\frontend\\postcss.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arda\\.gemini\\antigravity\\scratch\\restin-ai\\frontend\\public\\service-worker.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":101,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":101,"endColumn":17},{"ruleId":"no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":145,"column":12,"nodeType":"Identifier","messageId":"unusedVar","endLine":145,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Service Worker - Offline Asset Caching & Network Resilience\r\n * \r\n * Strategies:\r\n * - Static assets: Cache-first\r\n * - API calls: Network-first with offline fallback\r\n * - Images: Cache-first with network fallback\r\n */\r\n\r\nconst CACHE_VERSION = 'restin-v1';\r\nconst STATIC_CACHE = `${CACHE_VERSION}-static`;\r\nconst API_CACHE = `${CACHE_VERSION}-api`;\r\nconst IMAGE_CACHE = `${CACHE_VERSION}-images`;\r\n\r\nconst STATIC_ASSETS = [\r\n  '/',\r\n  '/index.html',\r\n  '/static/js/bundle.js',\r\n  '/static/css/main.css',\r\n  '/manifest.json'\r\n];\r\n\r\n// Install - Cache static assets\r\nself.addEventListener('install', (event) => {\r\n  console.log('­şôĞ Service Worker installing...');\r\n\r\n  event.waitUntil(\r\n    caches.open(STATIC_CACHE).then((cache) => {\r\n      return cache.addAll(STATIC_ASSETS).catch(err => {\r\n        console.warn('ÔÜá´©Å Some assets failed to cache:', err);\r\n      });\r\n    })\r\n  );\r\n\r\n  self.skipWaiting();\r\n});\r\n\r\n// Activate - Clean up old caches\r\nself.addEventListener('activate', (event) => {\r\n  console.log('Ô£à Service Worker activated');\r\n\r\n  event.waitUntil(\r\n    caches.keys().then((cacheNames) => {\r\n      return Promise.all(\r\n        cacheNames\r\n          .filter((name) => name.startsWith('restin-') && name !== STATIC_CACHE && name !== API_CACHE && name !== IMAGE_CACHE)\r\n          .map((name) => {\r\n            console.log('­şùæ´©Å Deleting old cache:', name);\r\n            return caches.delete(name);\r\n          })\r\n      );\r\n    })\r\n  );\r\n\r\n  self.clients.claim();\r\n});\r\n\r\n// Fetch - Handle requests\r\nself.addEventListener('fetch', (event) => {\r\n  const { request } = event;\r\n  const url = new URL(request.url);\r\n\r\n  // Auth - Bypass Service Worker\r\n  if (url.pathname.startsWith('/api/auth/')) {\r\n    return;\r\n  }\r\n\r\n  // Bypass Service Worker for local development ports and Edge Gateway\r\n  if (url.hostname === 'localhost' || url.hostname === '127.0.0.1') {\r\n    if (url.port === '8080' || url.port === '8081' || url.port === '5000' || url.port === '3000' || url.port === '8001') {\r\n      return;\r\n    }\r\n  }\r\n\r\n  // API calls - Network first, cache fallback\r\n  if (url.pathname.startsWith('/api/')) {\r\n    event.respondWith(networkFirstStrategy(request));\r\n  }\r\n  // Images - Cache first\r\n  else if (request.destination === 'image') {\r\n    event.respondWith(cacheFirstStrategy(request, IMAGE_CACHE));\r\n  }\r\n  // Static assets - Cache first\r\n  else {\r\n    event.respondWith(cacheFirstStrategy(request, STATIC_CACHE));\r\n  }\r\n});\r\n\r\n// Network-first strategy (for API calls)\r\nasync function networkFirstStrategy(request) {\r\n  try {\r\n    const response = await fetch(request);\r\n\r\n    // Cache successful GET requests\r\n    if (request.method === 'GET' && response.status === 200) {\r\n      const cache = await caches.open(API_CACHE);\r\n      cache.put(request, response.clone());\r\n    }\r\n\r\n    return response;\r\n  } catch (error) {\r\n    // Network failed - try cache\r\n    const cached = await caches.match(request);\r\n\r\n    if (cached) {\r\n      console.log('­şôĞ Serving from cache (offline):', request.url);\r\n      return cached;\r\n    }\r\n\r\n    // No cache - return offline response with clear error\r\n    return new Response(\r\n      JSON.stringify({\r\n        ok: false,\r\n        error: {\r\n          code: 'OFFLINE',\r\n          message: 'Network access failed and no cached response available.'\r\n        },\r\n        offline: true\r\n      }),\r\n      {\r\n        status: 202,\r\n        headers: { 'Content-Type': 'application/json' }\r\n      }\r\n    );\r\n  }\r\n}\r\n\r\n// Cache-first strategy (for static assets)\r\nasync function cacheFirstStrategy(request, cacheName) {\r\n  const cached = await caches.match(request);\r\n\r\n  if (cached) {\r\n    return cached;\r\n  }\r\n\r\n  try {\r\n    const response = await fetch(request);\r\n\r\n    if (request.method === 'GET' && response.status === 200) {\r\n      const cache = await caches.open(cacheName);\r\n      cache.put(request, response.clone());\r\n    }\r\n\r\n    return response;\r\n  } catch (error) {\r\n    // Network failed and no cache\r\n    console.error('ÔØî Asset not available offline:', request.url);\r\n\r\n    return new Response('Offline - Asset not cached', {\r\n      status: 503,\r\n      statusText: 'Service Unavailable'\r\n    });\r\n  }\r\n}\r\n\r\n// Background sync for queued operations\r\nself.addEventListener('sync', (event) => {\r\n  if (event.tag === 'sync-offline-queue') {\r\n    console.log('­şöä Background sync triggered');\r\n    event.waitUntil(syncOfflineQueue());\r\n  }\r\n});\r\n\r\nasync function syncOfflineQueue() {\r\n  // This would trigger the SyncService from the client\r\n  // Send message to all clients to start sync\r\n  const clients = await self.clients.matchAll();\r\n  clients.forEach(client => {\r\n    client.postMessage({\r\n      type: 'TRIGGER_SYNC',\r\n      timestamp: new Date().toISOString()\r\n    });\r\n  });\r\n}\r\n\r\n// Push notifications for sync status\r\nself.addEventListener('push', (event) => {\r\n  const data = event.data?.json() || {};\r\n\r\n  if (data.type === 'SYNC_COMPLETE') {\r\n    self.registration.showNotification('Sync Complete', {\r\n      body: `${data.synced_count} operations synced successfully`,\r\n      icon: '/logo192.png',\r\n      badge: '/logo192.png'\r\n    });\r\n  }\r\n});\r\n\r\nconsole.log('­şÜÇ Service Worker loaded');\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arda\\.gemini\\antigravity\\scratch\\restin-ai\\frontend\\scripts\\guard_no_duplicate_symbols.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'countOccurrences' is defined but never used.","line":12,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":26,"suggestions":[{"messageId":"removeVar","data":{"varName":"countOccurrences"},"fix":{"range":[420,560],"text":""},"desc":"Remove unused variable 'countOccurrences'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Duplicate Symbol Guard - Prevents build failures\r\nconst fs = require(\"fs\");\r\nconst path = require(\"path\");\r\n\r\nconst TARGETS = [\r\n  { file: \"src/pages/pos/POSMain.js\", symbols: [\"calculateTotal\", \"sendOrder\", \"POSMain\"] },\r\n  { file: \"src/pages/kds/KDSMain.js\", symbols: [\"KDSMain\"] },\r\n  { file: \"src/lib/api.js\", symbols: [\"refreshToken\", \"api\"] },\r\n  { file: \"src/App.js\", symbols: [\"App\", \"RootOverlays\"] }\r\n];\r\n\r\nfunction countOccurrences(text, needle) {\r\n  const re = new RegExp(\"\\\\b\" + needle + \"\\\\b\", \"g\");\r\n  return (text.match(re) || []).length;\r\n}\r\n\r\nlet failed = false;\r\n\r\nfor (const t of TARGETS) {\r\n  const filePath = path.join(\"/app/frontend\", t.file);\r\n  if (!fs.existsSync(filePath)) {\r\n    console.warn(`[GUARD] Skipping ${t.file} (not found)`);\r\n    continue;\r\n  }\r\n  \r\n  const src = fs.readFileSync(filePath, \"utf8\");\r\n\r\n  for (const sym of t.symbols) {\r\n    // Count \"const symbol\" and \"function symbol\" declarations\r\n    const constDef = (src.match(new RegExp(\"\\\\bconst\\\\s+\" + sym + \"\\\\b\", \"g\")) || []).length;\r\n    const fnDef = (src.match(new RegExp(\"\\\\bfunction\\\\s+\" + sym + \"\\\\b\", \"g\")) || []).length;\r\n    const asyncFnDef = (src.match(new RegExp(\"\\\\basync\\\\s+function\\\\s+\" + sym + \"\\\\b\", \"g\")) || []).length;\r\n\r\n    const total = constDef + fnDef + asyncFnDef;\r\n    \r\n    if (total > 1) {\r\n      console.error(`[GUARD] ÔØî Duplicate definition: ${sym} in ${t.file}`);\r\n      console.error(`        const: ${constDef}, function: ${fnDef}, async function: ${asyncFnDef}`);\r\n      failed = true;\r\n    }\r\n  }\r\n\r\n  // Detect adjacent duplicate lines (common patch error)\r\n  const lines = src.split(\"\\n\");\r\n  for (let i = 0; i < lines.length - 1; i++) {\r\n    const current = lines[i].trim();\r\n    const next = lines[i + 1].trim();\r\n    \r\n    if (current && current === next && current.length > 10) {\r\n      console.error(`[GUARD] ÔØî Adjacent duplicate line in ${t.file} at line ${i + 1}:`);\r\n      console.error(`        \"${current.slice(0, 80)}\"`);\r\n      failed = true;\r\n      break;  // One per file is enough\r\n    }\r\n  }\r\n}\r\n\r\nif (failed) {\r\n  console.error(\"\\n[GUARD] ÔØî BUILD BLOCKED - Fix duplicates and retry deploy.\\n\");\r\n  process.exit(1);\r\n}\r\n\r\nconsole.log(\"[GUARD] Ô£ô No duplicate definitions or adjacent duplicate lines found.\");\r\nprocess.exit(0);\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arda\\.gemini\\antigravity\\scratch\\restin-ai\\frontend\\src\\__tests__\\Login.test.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'BrowserRouter' is defined but never used.","line":7,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":23,"suggestions":[{"messageId":"removeVar","data":{"varName":"BrowserRouter"},"fix":{"range":[162,211],"text":""},"desc":"Remove unused variable 'BrowserRouter'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'Login' is defined but never used.","line":8,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":8,"endColumn":13,"suggestions":[{"messageId":"removeVar","data":{"varName":"Login"},"fix":{"range":[220,231],"text":""},"desc":"Remove unused variable 'Login'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'AuthContext' is defined but never used.","line":9,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":21,"suggestions":[{"messageId":"removeVar","data":{"varName":"AuthContext"},"fix":{"range":[250,303],"text":""},"desc":"Remove unused variable 'AuthContext'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'VenueContext' is defined but never used.","line":10,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":10,"endColumn":22,"suggestions":[{"messageId":"removeVar","data":{"varName":"VenueContext"},"fix":{"range":[305,360],"text":""},"desc":"Remove unused variable 'VenueContext'."}]},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":14,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":14,"endColumn":5},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":16,"column":12,"nodeType":"Identifier","messageId":"undef","endLine":16,"endColumn":16},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":21,"column":19,"nodeType":"Identifier","messageId":"undef","endLine":21,"endColumn":23},{"ruleId":"no-undef","severity":2,"message":"'describe' is not defined.","line":39,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":39,"endColumn":9},{"ruleId":"no-undef","severity":2,"message":"'beforeEach' is not defined.","line":40,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":40,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'jest' is not defined.","line":41,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":41,"endColumn":9},{"ruleId":"no-undef","severity":2,"message":"'test' is not defined.","line":45,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":45,"endColumn":7},{"ruleId":"no-undef","severity":2,"message":"'expect' is not defined.","line":65,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":65,"endColumn":13},{"ruleId":"no-undef","severity":2,"message":"'test' is not defined.","line":69,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":69,"endColumn":7},{"ruleId":"no-undef","severity":2,"message":"'expect' is not defined.","line":89,"column":7,"nodeType":"Identifier","messageId":"undef","endLine":89,"endColumn":13},{"ruleId":"no-unused-vars","severity":1,"message":"'pinBoxes' is assigned a value but never used.","line":96,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":96,"endColumn":23,"suggestions":[{"messageId":"removeVar","data":{"varName":"pinBoxes"},"fix":{"range":[2817,2954],"text":""},"desc":"Remove unused variable 'pinBoxes'."}]},{"ruleId":"no-undef","severity":2,"message":"'expect' is not defined.","line":100,"column":9,"nodeType":"Identifier","messageId":"undef","endLine":100,"endColumn":15},{"ruleId":"no-undef","severity":2,"message":"'test' is not defined.","line":106,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":106,"endColumn":7},{"ruleId":"no-undef","severity":2,"message":"'expect' is not defined.","line":120,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":120,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'test' is not defined.","line":123,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":123,"endColumn":7},{"ruleId":"no-undef","severity":2,"message":"'expect' is not defined.","line":128,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":128,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'expect' is not defined.","line":131,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":131,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'test' is not defined.","line":136,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":136,"endColumn":7},{"ruleId":"no-undef","severity":2,"message":"'expect' is not defined.","line":140,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":140,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'expect' is not defined.","line":144,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":144,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'test' is not defined.","line":147,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":147,"endColumn":7},{"ruleId":"no-undef","severity":2,"message":"'expect' is not defined.","line":170,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":170,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'describe' is not defined.","line":174,"column":1,"nodeType":"Identifier","messageId":"undef","endLine":174,"endColumn":9},{"ruleId":"no-undef","severity":2,"message":"'test' is not defined.","line":175,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":175,"endColumn":7},{"ruleId":"no-undef","severity":2,"message":"'expect' is not defined.","line":180,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":180,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'test' is not defined.","line":183,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":183,"endColumn":7},{"ruleId":"no-undef","severity":2,"message":"'expect' is not defined.","line":187,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":187,"endColumn":11},{"ruleId":"no-undef","severity":2,"message":"'test' is not defined.","line":192,"column":3,"nodeType":"Identifier","messageId":"undef","endLine":192,"endColumn":7},{"ruleId":"no-undef","severity":2,"message":"'expect' is not defined.","line":196,"column":5,"nodeType":"Identifier","messageId":"undef","endLine":196,"endColumn":11}],"suppressedMessages":[],"errorCount":28,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Login Component Tests\r\n * Tests for PIN auto-submit and reset logic\r\n */\r\n\r\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\r\nimport { BrowserRouter } from 'react-router-dom';\r\nimport Login from '../pages/Login';\r\nimport { AuthContext } from '../context/AuthContext';\r\nimport { VenueContext } from '../context/VenueContext';\r\nimport { authAPI } from '../lib/api';\r\n\r\n// Mock the API\r\njest.mock('../lib/api', () => ({\r\n  authAPI: {\r\n    login: jest.fn(),\r\n  },\r\n}));\r\n\r\n// Mock contexts\r\nconst mockLogin = jest.fn();\r\nconst mockVenues = [\r\n  { id: 'venue-1', name: 'Test Venue 1' },\r\n  { id: 'venue-2', name: 'Test Venue 2' },\r\n];\r\n\r\nconst renderLogin = (venuesLoading = false, venues = mockVenues) => {\r\n  return render(\r\n    <BrowserRouter>\r\n      <AuthContext.Provider value={{ login: mockLogin }}>\r\n        <VenueContext.Provider value={{ venues, loading: venuesLoading }}>\r\n          <Login />\r\n        </VenueContext.Provider>\r\n      </AuthContext.Provider>\r\n    </BrowserRouter>\r\n  );\r\n};\r\n\r\ndescribe('Login Component - PIN Auto-Submit', () => {\r\n  beforeEach(() => {\r\n    jest.clearAllMocks();\r\n    localStorage.clear();\r\n  });\r\n\r\n  test('auto-submits when 4th digit is entered', async () => {\r\n    authAPI.login.mockResolvedValue({\r\n      data: { user: { name: 'Test User' }, token: 'test-token' },\r\n    });\r\n\r\n    renderLogin();\r\n\r\n    // Select venue first\r\n    const venueSelect = screen.getByTestId('venue-select');\r\n    fireEvent.click(venueSelect);\r\n    fireEvent.click(screen.getByText('Test Venue 1'));\r\n\r\n    // Enter 4 digits\r\n    fireEvent.click(screen.getByTestId('pin-1'));\r\n    fireEvent.click(screen.getByTestId('pin-2'));\r\n    fireEvent.click(screen.getByTestId('pin-3'));\r\n    fireEvent.click(screen.getByTestId('pin-4'));\r\n\r\n    // Should auto-submit without pressing ENTER\r\n    await waitFor(() => {\r\n      expect(authAPI.login).toHaveBeenCalled();\r\n    });\r\n  });\r\n\r\n  test('resets PIN on failed login', async () => {\r\n    authAPI.login.mockRejectedValue({\r\n      response: { data: { detail: 'Invalid PIN' } },\r\n    });\r\n\r\n    renderLogin();\r\n\r\n    // Select venue\r\n    const venueSelect = screen.getByTestId('venue-select');\r\n    fireEvent.click(venueSelect);\r\n    fireEvent.click(screen.getByText('Test Venue 1'));\r\n\r\n    // Enter 4 digits\r\n    fireEvent.click(screen.getByTestId('pin-1'));\r\n    fireEvent.click(screen.getByTestId('pin-2'));\r\n    fireEvent.click(screen.getByTestId('pin-3'));\r\n    fireEvent.click(screen.getByTestId('pin-4'));\r\n\r\n    // Wait for auto-submit and error handling\r\n    await waitFor(() => {\r\n      expect(screen.getByText('Incorrect PIN')).toBeInTheDocument();\r\n    });\r\n\r\n    // PIN should be reset after 500ms\r\n    await waitFor(\r\n      () => {\r\n        // All PIN boxes should be empty (no filled indicators)\r\n        const pinBoxes = screen.getAllByRole('button').filter((btn) =>\r\n          btn.getAttribute('data-testid')?.startsWith('pin-')\r\n        );\r\n        // Check that PIN display is cleared\r\n        expect(screen.queryByText('Incorrect PIN')).not.toBeInTheDocument();\r\n      },\r\n      { timeout: 600 }\r\n    );\r\n  });\r\n\r\n  test('CLEAR button resets PIN immediately', () => {\r\n    renderLogin();\r\n\r\n    // Enter 3 digits\r\n    fireEvent.click(screen.getByTestId('pin-1'));\r\n    fireEvent.click(screen.getByTestId('pin-2'));\r\n    fireEvent.click(screen.getByTestId('pin-3'));\r\n\r\n    // Click CLEAR\r\n    fireEvent.click(screen.getByTestId('pin-clear'));\r\n\r\n    // PIN should be immediately cleared\r\n    // (Visual check - all PIN boxes should be empty)\r\n    const pinBoxes = document.querySelectorAll('[class*=\"rounded-full\"]');\r\n    expect(pinBoxes.length).toBe(0);\r\n  });\r\n\r\n  test('disables keypad when no venues available', () => {\r\n    renderLogin(false, []); // No venues\r\n\r\n    // All PIN buttons should be disabled\r\n    const pin1 = screen.getByTestId('pin-1');\r\n    expect(pin1).toBeDisabled();\r\n\r\n    // Should show helper text\r\n    expect(\r\n      screen.getByText(/No venues available/i)\r\n    ).toBeInTheDocument();\r\n  });\r\n\r\n  test('shows loading state for venues', () => {\r\n    renderLogin(true, []); // Loading venues\r\n\r\n    // Select should show loading placeholder\r\n    expect(screen.getByText('Loading venues...')).toBeInTheDocument();\r\n\r\n    // PIN pad should be disabled\r\n    const pin1 = screen.getByTestId('pin-1');\r\n    expect(pin1).toBeDisabled();\r\n  });\r\n\r\n  test('prevents multiple PIN entries during loading', async () => {\r\n    authAPI.login.mockImplementation(\r\n      () => new Promise((resolve) => setTimeout(resolve, 1000))\r\n    );\r\n\r\n    renderLogin();\r\n\r\n    // Select venue\r\n    const venueSelect = screen.getByTestId('venue-select');\r\n    fireEvent.click(venueSelect);\r\n    fireEvent.click(screen.getByText('Test Venue 1'));\r\n\r\n    // Enter 4 digits to trigger auto-submit\r\n    fireEvent.click(screen.getByTestId('pin-1'));\r\n    fireEvent.click(screen.getByTestId('pin-2'));\r\n    fireEvent.click(screen.getByTestId('pin-3'));\r\n    fireEvent.click(screen.getByTestId('pin-4'));\r\n\r\n    // Try to click another digit while loading\r\n    fireEvent.click(screen.getByTestId('pin-5'));\r\n\r\n    // Should not add 5th digit (PIN should stay at 4 digits)\r\n    const pin1Button = screen.getByTestId('pin-1');\r\n    expect(pin1Button).toBeDisabled();\r\n  });\r\n});\r\n\r\ndescribe('Login Component - Brand Colors', () => {\r\n  test('renders brand red accent on .AI text', () => {\r\n    renderLogin();\r\n\r\n    // Check that .AI span has brand red color\r\n    const aiText = screen.getByText('.AI');\r\n    expect(aiText).toHaveStyle({ color: 'var(--brand-accent)' });\r\n  });\r\n\r\n  test('renders ENTER button with brand red background', () => {\r\n    renderLogin();\r\n\r\n    const enterButton = screen.getByTestId('pin-submit');\r\n    expect(enterButton).toHaveStyle({\r\n      backgroundColor: 'var(--brand-accent)',\r\n    });\r\n  });\r\n\r\n  test('renders active tab with brand red background', () => {\r\n    renderLogin();\r\n\r\n    const adminTab = screen.getByTestId('login-target-admin');\r\n    expect(adminTab).toHaveStyle({\r\n      backgroundColor: 'var(--brand-accent)',\r\n    });\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arda\\.gemini\\antigravity\\scratch\\restin-ai\\frontend\\src\\features\\restin\\crm\\index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arda\\.gemini\\antigravity\\scratch\\restin-ai\\frontend\\src\\features\\restin\\index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arda\\.gemini\\antigravity\\scratch\\restin-ai\\frontend\\src\\features\\restin\\radar\\index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arda\\.gemini\\antigravity\\scratch\\restin-ai\\frontend\\src\\features\\restin\\studio\\index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arda\\.gemini\\antigravity\\scratch\\restin-ai\\frontend\\src\\features\\restin\\voice\\index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arda\\.gemini\\antigravity\\scratch\\restin-ai\\frontend\\src\\features\\restin\\web\\index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arda\\.gemini\\antigravity\\scratch\\restin-ai\\frontend\\src\\index.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'React' is defined but never used.","line":12,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":12,"endColumn":13,"suggestions":[{"messageId":"removeVar","data":{"varName":"React"},"fix":{"range":[363,374],"text":""},"desc":"Remove unused variable 'React'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'QueryClientProvider' is defined but never used.","line":14,"column":23,"nodeType":"Identifier","messageId":"unusedVar","endLine":14,"endColumn":42,"suggestions":[{"messageId":"removeVar","data":{"varName":"QueryClientProvider"},"fix":{"range":[446,467],"text":""},"desc":"Remove unused variable 'QueryClientProvider'."}]},{"ruleId":"no-unused-vars","severity":1,"message":"'App' is defined but never used.","line":17,"column":8,"nodeType":"Identifier","messageId":"unusedVar","endLine":17,"endColumn":11,"suggestions":[{"messageId":"removeVar","data":{"varName":"App"},"fix":{"range":[579,588],"text":""},"desc":"Remove unused variable 'App'."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import * as Sentry from \"@sentry/react\";\r\n\r\nSentry.init({\r\n  dsn: \"https://c8948ba4809a8afc56aaac4380bcae56@o4510853881921536.ingest.de.sentry.io/4510853958467664\",\r\n  environment: process.env.NODE_ENV,\r\n  enabled: process.env.NODE_ENV === \"production\",\r\n  tracesSampleRate: 0.2,\r\n  replaysSessionSampleRate: 0.1,\r\n  replaysOnErrorSampleRate: 1.0,\r\n});\r\n\r\nimport React from \"react\";\r\nimport ReactDOM from \"react-dom/client\";\r\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\r\nimport './lib/i18n/config'; // Initialize i18n\r\nimport \"./index.css\";\r\nimport App from \"./App\";\r\nimport * as serviceWorkerRegistration from './serviceWorkerRegistration';\r\n\r\nconst queryClient = new QueryClient({\r\n  defaultOptions: {\r\n    queries: {\r\n      retry: 1,\r\n      refetchOnWindowFocus: false,\r\n      staleTime: 2 * 60_000,   // 2 min ÔÇö config/menu data rarely changes mid-session\r\n      gcTime: 10 * 60_000,     // 10 min ÔÇö keep cache warm across navigations\r\n    },\r\n  },\r\n});\r\n\r\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\r\nroot.render(\r\n  <React.StrictMode>\r\n    <QueryClientProvider client={queryClient}>\r\n      <App />\r\n    </QueryClientProvider>\r\n  </React.StrictMode>,\r\n);\r\n\r\nserviceWorkerRegistration.unregister();\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arda\\.gemini\\antigravity\\scratch\\restin-ai\\frontend\\src\\lib\\schemas\\index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arda\\.gemini\\antigravity\\scratch\\restin-ai\\frontend\\src\\routes\\index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arda\\.gemini\\antigravity\\scratch\\restin-ai\\frontend\\src\\serviceWorkerRegistration.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\arda\\.gemini\\antigravity\\scratch\\restin-ai\\frontend\\tailwind.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
